2025-06-28 17:08:46:332 grammar LogManager.java:25 before: (LEXER_GRAMMAR MerlynxLexer (@ lexer header {
  package com.merlab.merlynx.lexer;
}) (RULES (RULE PIPELINE (BLOCK (ALT 'pipeline'))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE PROCESS (BLOCK (ALT 'process'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE RULE (BLOCK (ALT 'rule'))) (RULE FILTER (BLOCK (ALT 'filter'))) (RULE AMPLIFY (BLOCK (ALT 'amplify'))) (RULE NORMALIZE (BLOCK (ALT 'normalize'))) (RULE COMBINE (BLOCK (ALT 'combine'))) (RULE IF (BLOCK (ALT 'if'))) (RULE THEN (BLOCK (ALT 'then'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE END (BLOCK (ALT 'end'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE FUNCTION (BLOCK (ALT 'function'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE CONST (BLOCK (ALT 'const'))) (RULE LET (BLOCK (ALT 'let'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NULL (BLOCK (ALT 'null'))) (RULE AND (BLOCK (ALT 'and'))) (RULE OR (BLOCK (ALT 'or'))) (RULE NOT (BLOCK (ALT 'not'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IMPORT (BLOCK (ALT 'import'))) (RULE INT (BLOCK (ALT 'int'))) (RULE FLOAT (BLOCK (ALT 'float'))) (RULE BOOL (BLOCK (ALT 'bool'))) (RULE STRING (BLOCK (ALT 'string'))) (RULE SIGNAL (BLOCK (ALT 'signal'))) (RULE ARRAY (BLOCK (ALT 'array'))) (RULE MAP (BLOCK (ALT 'map'))) (RULE FACT (BLOCK (ALT 'fact'))) (RULE QUERY (BLOCK (ALT 'query'))) (RULE FORALL (BLOCK (ALT 'forall'))) (RULE EXISTS (BLOCK (ALT 'exists'))) (RULE TRAIN (BLOCK (ALT 'train'))) (RULE PREDICT (BLOCK (ALT 'predict'))) (RULE MODEL (BLOCK (ALT 'model'))) (RULE DATASET (BLOCK (ALT 'dataset'))) (RULE FFT (BLOCK (ALT 'fft'))) (RULE IFFT (BLOCK (ALT 'ifft'))) (RULE DECIMATE (BLOCK (ALT 'decimate'))) (RULE INTERPOLATE (BLOCK (ALT 'interpolate'))) (RULE IMPLIES (BLOCK (ALT ':-'))) (RULE ID (BLOCK (ALT [a-zA-Z_] (* (BLOCK (ALT [a-zA-Z_0-9])))))) (RULE INT_LITERAL (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOAT_LITERAL (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) '.' (* (BLOCK (ALT [0-9])))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\r\n]))))) '"'))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE BLOCK_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE COLON (BLOCK (ALT ':'))) (RULE LPAREN (BLOCK (ALT '('))) (RULE RPAREN (BLOCK (ALT ')'))) (RULE COMMA (BLOCK (ALT ','))) (RULE PLUS (BLOCK (ALT '+'))) (RULE MINUS (BLOCK (ALT '-'))) (RULE MULT (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE GT (BLOCK (ALT '>'))) (RULE LT (BLOCK (ALT '<'))) (RULE GE (BLOCK (ALT '>='))) (RULE LE (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!=')))))
2025-06-28 17:08:46:363 grammar LogManager.java:25 after: (LEXER_GRAMMAR MerlynxLexer (@ lexer header {
  package com.merlab.merlynx.lexer;
}) (RULES (RULE PIPELINE (BLOCK (ALT 'pipeline'))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE PROCESS (BLOCK (ALT 'process'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE RULE (BLOCK (ALT 'rule'))) (RULE FILTER (BLOCK (ALT 'filter'))) (RULE AMPLIFY (BLOCK (ALT 'amplify'))) (RULE NORMALIZE (BLOCK (ALT 'normalize'))) (RULE COMBINE (BLOCK (ALT 'combine'))) (RULE IF (BLOCK (ALT 'if'))) (RULE THEN (BLOCK (ALT 'then'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE END (BLOCK (ALT 'end'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE FUNCTION (BLOCK (ALT 'function'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE CONST (BLOCK (ALT 'const'))) (RULE LET (BLOCK (ALT 'let'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NULL (BLOCK (ALT 'null'))) (RULE AND (BLOCK (ALT 'and'))) (RULE OR (BLOCK (ALT 'or'))) (RULE NOT (BLOCK (ALT 'not'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IMPORT (BLOCK (ALT 'import'))) (RULE INT (BLOCK (ALT 'int'))) (RULE FLOAT (BLOCK (ALT 'float'))) (RULE BOOL (BLOCK (ALT 'bool'))) (RULE STRING (BLOCK (ALT 'string'))) (RULE SIGNAL (BLOCK (ALT 'signal'))) (RULE ARRAY (BLOCK (ALT 'array'))) (RULE MAP (BLOCK (ALT 'map'))) (RULE FACT (BLOCK (ALT 'fact'))) (RULE QUERY (BLOCK (ALT 'query'))) (RULE FORALL (BLOCK (ALT 'forall'))) (RULE EXISTS (BLOCK (ALT 'exists'))) (RULE TRAIN (BLOCK (ALT 'train'))) (RULE PREDICT (BLOCK (ALT 'predict'))) (RULE MODEL (BLOCK (ALT 'model'))) (RULE DATASET (BLOCK (ALT 'dataset'))) (RULE FFT (BLOCK (ALT 'fft'))) (RULE IFFT (BLOCK (ALT 'ifft'))) (RULE DECIMATE (BLOCK (ALT 'decimate'))) (RULE INTERPOLATE (BLOCK (ALT 'interpolate'))) (RULE IMPLIES (BLOCK (ALT ':-'))) (RULE ID (BLOCK (ALT [a-zA-Z_] (* (BLOCK (ALT [a-zA-Z_0-9])))))) (RULE INT_LITERAL (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOAT_LITERAL (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) '.' (* (BLOCK (ALT [0-9])))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\r\n]))))) '"'))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE BLOCK_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE COLON (BLOCK (ALT ':'))) (RULE LPAREN (BLOCK (ALT '('))) (RULE RPAREN (BLOCK (ALT ')'))) (RULE COMMA (BLOCK (ALT ','))) (RULE PLUS (BLOCK (ALT '+'))) (RULE MINUS (BLOCK (ALT '-'))) (RULE MULT (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE GT (BLOCK (ALT '>'))) (RULE LT (BLOCK (ALT '<'))) (RULE GE (BLOCK (ALT '>='))) (RULE LE (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!=')))))
2025-06-28 17:08:46:857 action-translator LogManager.java:25 translate 
  package com.merlab.merlynx.lexer;

2025-06-28 17:08:47:082 grammar LogManager.java:25 before: (PARSER_GRAMMAR Merlynx (@ header {
package com.merlab.merlynx.parser;
}) (OPTIONS (= tokenVocab MerlynxLexer)) (RULES (RULE program (BLOCK (ALT EOF))) (RULE program (BLOCK (ALT (* (BLOCK (ALT statement))) EOF))) (RULE statement (BLOCK (ALT pipelineDecl) (ALT functionDecl) (ALT ruleDecl) (ALT expressionStatement))) (RULE pipelineDecl (BLOCK (ALT PIPELINE ID NEWLINE pipelineBody END))) (RULE pipelineBody (BLOCK (ALT (+ (BLOCK (ALT pipelineStatement NEWLINE)))))) (RULE pipelineStatement (BLOCK (ALT INPUT COLON ID) (ALT PROCESS COLON expression) (ALT OUTPUT COLON ID))) (RULE functionDecl (BLOCK (ALT FUNCTION ID LPAREN (? (BLOCK (ALT parameterList))) RPAREN block END))) (RULE parameterList (BLOCK (ALT ID (* (BLOCK (ALT COMMA ID)))))) (RULE block (BLOCK (ALT (* (BLOCK (ALT statement)))))) (RULE ruleDecl (BLOCK (ALT RULE ID IMPLIES expression))) (RULE expressionStatement (BLOCK (ALT expression))) (RULE expression (BLOCK (ALT literal) (ALT ID) (ALT functionCall) (ALT LPAREN expression RPAREN) (ALT expression binaryOp expression) (ALT unaryOp expression))) (RULE functionCall (BLOCK (ALT ID LPAREN (? (BLOCK (ALT argumentList))) RPAREN))) (RULE argumentList (BLOCK (ALT expression (* (BLOCK (ALT COMMA expression)))))) (RULE literal (BLOCK (ALT INT_LITERAL) (ALT FLOAT_LITERAL) (ALT STRING_LITERAL) (ALT TRUE) (ALT FALSE) (ALT NULL))) (RULE binaryOp (BLOCK (ALT PLUS) (ALT MINUS) (ALT MULT) (ALT DIV) (ALT GT) (ALT LT) (ALT GE) (ALT LE) (ALT EQ) (ALT NEQ) (ALT AND) (ALT OR))) (RULE unaryOp (BLOCK (ALT NOT) (ALT MINUS)))))
2025-06-28 17:08:47:093 grammar LogManager.java:25 after: (PARSER_GRAMMAR Merlynx (@ header {
package com.merlab.merlynx.parser;
}) (OPTIONS (= tokenVocab MerlynxLexer)) (RULES (RULE program (BLOCK (ALT EOF))) (RULE program (BLOCK (ALT (* (BLOCK (ALT statement))) EOF))) (RULE statement (BLOCK (ALT pipelineDecl) (ALT functionDecl) (ALT ruleDecl) (ALT expressionStatement))) (RULE pipelineDecl (BLOCK (ALT PIPELINE ID NEWLINE pipelineBody END))) (RULE pipelineBody (BLOCK (ALT (+ (BLOCK (ALT pipelineStatement NEWLINE)))))) (RULE pipelineStatement (BLOCK (ALT INPUT COLON ID) (ALT PROCESS COLON expression) (ALT OUTPUT COLON ID))) (RULE functionDecl (BLOCK (ALT FUNCTION ID LPAREN (? (BLOCK (ALT parameterList))) RPAREN block END))) (RULE parameterList (BLOCK (ALT ID (* (BLOCK (ALT COMMA ID)))))) (RULE block (BLOCK (ALT (* (BLOCK (ALT statement)))))) (RULE ruleDecl (BLOCK (ALT RULE ID IMPLIES expression))) (RULE expressionStatement (BLOCK (ALT expression))) (RULE expression (BLOCK (ALT literal) (ALT ID) (ALT functionCall) (ALT LPAREN expression RPAREN) (ALT expression binaryOp expression) (ALT unaryOp expression))) (RULE functionCall (BLOCK (ALT ID LPAREN (? (BLOCK (ALT argumentList))) RPAREN))) (RULE argumentList (BLOCK (ALT expression (* (BLOCK (ALT COMMA expression)))))) (RULE literal (BLOCK (ALT (SET INT_LITERAL FLOAT_LITERAL STRING_LITERAL TRUE FALSE NULL)))) (RULE binaryOp (BLOCK (ALT (SET PLUS MINUS MULT DIV GT LT GE LE EQ NEQ AND OR)))) (RULE unaryOp (BLOCK (ALT (SET NOT MINUS))))))
